
rules_version = '2';

service cloud.firestore {

  // ==================================
  // == Helper Functions ==
  // ==================================

  function isAuthenticated() {
    return request.auth != null;
  }

  function isDoctor() {
    if (!isAuthenticated() || request.auth.uid == null) {
      return false;
    }
    let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
    // Check document existence and data before accessing userType
    return exists(userDocPath) &&
           get(userDocPath).data != null &&
           get(userDocPath).data.userType == 'doctor';
  }

  function isPatient() {
    if (!isAuthenticated() || request.auth.uid == null) {
      return false;
    }
    let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
    // Check document existence and data before accessing userType
    return exists(userDocPath) &&
           get(userDocPath).data != null &&
           get(userDocPath).data.userType == 'patient';
  }

  // Check if the authenticated doctor manages the patient record.
  function isDoctorManagingPatient(patientRecordId) {
    if (!isDoctor() || !(patientRecordId is string) || patientRecordId.size() == 0) {
      return false;
    }
    let patientRecordPath = /databases/$(database)/documents/patientRecords/$(patientRecordId);
    return exists(patientRecordPath) &&
           get(patientRecordPath).data != null &&
           get(patientRecordPath).data.doctorId == request.auth.uid;
  }

  // Check if the authenticated patient is linked to the patient record.
  function isLinkedPatient(patientRecordId) {
    if (!isPatient() || !(patientRecordId is string) || patientRecordId.size() == 0) {
      return false;
    }
    let patientRecordPath = /databases/$(database)/documents/patientRecords/$(patientRecordId);
    return exists(patientRecordPath) &&
           get(patientRecordPath).data != null &&
           get(patientRecordPath).data.linkedAuthUid == request.auth.uid;
  }

  // ==================================
  // == Collection Rules ==
  // ==================================

  match /databases/{database}/documents {

    // == Users Collection ==
    match /users/{userId} {
      allow create: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.userType is string && (request.resource.data.userType == 'doctor' || request.resource.data.userType == 'patient') &&
                      request.resource.data.createdAt == request.time;

      allow read: if isAuthenticated() && (request.auth.uid == userId || isDoctor()); // Doctors can read any user for now, refine if needed

      allow update: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      // Prevent changing critical fields
                      request.resource.data.uid == resource.data.uid &&
                      request.resource.data.email == resource.data.email &&
                      request.resource.data.userType == resource.data.userType &&
                      request.resource.data.createdAt == resource.data.createdAt;
                      // Allow other fields (firstName, lastName) to be updated

      allow delete: if false; // Generally, don't allow client-side user deletion
    }

    // == PatientRecords Collection ==
    // For doctors creating and managing patient data records (not auth profiles)
    match /patientRecords/{recordId} {
      allow create: if isDoctor() &&
                      request.resource.data.doctorId == request.auth.uid &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.idNumber is string && request.resource.data.idNumber.size() > 0 &&
                      request.resource.data.initialPassword is string && request.resource.data.initialPassword.size() >= 6 &&
                      'createdAt' in request.resource.data && // Client sends serverTimestamp()
                      !('linkedAuthUid' in request.resource.data); // Cannot set linkedAuthUid on create

      // Read rule for Patient ID based login (unauthenticated query) - HIGHLY INSECURE for production.
      // Replace with a Cloud Function for production.
      // This also allows doctors and linked patients to read the record.
      allow get: if (request.auth == null && request.query.resource.data.idNumber != null) || // Allows unauth get for login IF query is specific enough on client
                   (isAuthenticated() && (isDoctorManagingPatient(recordId) || isLinkedPatient(recordId)));
      
      allow list: if isDoctor(); // Doctors can list records, client query MUST filter by doctorId
                   // Add rule for patients to list their own if linkedAuthUid is used for querying their record

      allow update: if isDoctorManagingPatient(recordId) &&
                      request.resource.data.doctorId == resource.data.doctorId && // doctorId cannot change
                      request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot change
                      // Allow other updates, e.g., linking a patient's Firebase Auth UID

      allow delete: if isDoctorManagingPatient(recordId);
    }

    // == AiInstructions Collection ==
    match /aiInstructions/{aiDocId_doctorId} { // Use a combined ID if doctorId is also a field in the doc
      allow read, write: if isDoctor() && request.auth.uid == aiDocId_doctorId;
    }

    // == Appointments Collection ==
    match /appointments/{appointmentId} {
      allow create: if isAuthenticated() &&
                      (
                        (isPatient() && request.resource.data.patientAuthUid == request.auth.uid) ||
                        (isDoctor() && request.resource.data.doctorId == request.auth.uid && 
                         request.resource.data.patientRecordId is string && isDoctorManagingPatient(request.resource.data.patientRecordId)) // Doctor can only create for their patients
                      ) &&
                      request.resource.data.appointmentDate is string && // Basic validation
                      request.resource.data.reason is string && request.resource.data.reason.size() > 0;


      allow list: if isAuthenticated() &&
                    (
                      (isPatient() && request.query.filters.size() > 0 && request.query.filters[0][2] == request.auth.uid) || // if patient queries by patientAuthUid
                      (isDoctor() && request.query.filters.size() > 0 && request.query.filters[0][2] == request.auth.uid)    // if doctor queries by doctorId
                    );
                    // This rule assumes the first filter is on patientAuthUid or doctorId. More robust would be separate paths or roles.

      allow get, update, delete: if isAuthenticated() &&
                                 (
                                   (isPatient() && resource.data.patientAuthUid == request.auth.uid) ||
                                   (isDoctor() && resource.data.doctorId == request.auth.uid)
                                 );
                                 // For update, add field validation
    }

    // == Diagnoses Collection ==
    match /diagnoses/{diagnosisId} {
      allow create: if request.resource.data.patientRecordId is string && 
                      isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.diagnosedBy == request.auth.uid &&
                      request.resource.data.diagnosisText is string && request.resource.data.diagnosisText.size() > 0 &&
                      request.resource.data.diagnosisDate is string;

      allow get: if resource.data.patientRecordId is string &&
                   isAuthenticated() &&
                   ( isDoctorManagingPatient(resource.data.patientRecordId) || isLinkedPatient(resource.data.patientRecordId) );

      allow list: if isDoctor(); // Doctor can list, client MUST filter by patientRecordId and ensure doctor manages that patient.

      allow update, delete: if resource.data.patientRecordId is string &&
                              isDoctorManagingPatient(resource.data.patientRecordId) &&
                              resource.data.diagnosedBy == request.auth.uid; // Only original diagnosing doctor
    }

    // == PatientDocuments Collection ==
    match /patientDocuments/{documentId} {
      allow create: if request.resource.data.patientRecordId is string &&
                      isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.uploadedBy == request.auth.uid &&
                      request.resource.data.documentName is string && request.resource.data.documentName.size() > 0 &&
                      request.resource.data.documentPath is string;

      allow get: if resource.data.patientRecordId is string &&
                   isAuthenticated() &&
                   ( isDoctorManagingPatient(resource.data.patientRecordId) || isLinkedPatient(resource.data.patientRecordId) );

      allow list: if isDoctor(); // Doctor can list, client MUST filter by patientRecordId.

      allow delete: if resource.data.patientRecordId is string &&
                      isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.uploadedBy == request.auth.uid; // Only original uploader
    }

    // == ChatMessages Collection ==
    match /chatMessages/{chatId} {
      allow create: if isAuthenticated() &&
                      isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.resource.data.isUser == true &&
                      request.resource.data.messageText is string && request.resource.data.messageText.size() > 0 &&
                      request.resource.data.sentAt == request.time; // Ensure client uses serverTimestamp

      allow get: if isAuthenticated() &&
                   isPatient() &&
                   resource.data.patientAuthUid == request.auth.uid;

      // Allow patients to list their own messages.
      // Client query must include: where("patientAuthUid", "==", request.auth.uid)
      allow list: if isAuthenticated() && isPatient();
                  // Doctor access to chat messages needs a different data model or Cloud Functions
                  // for security and to avoid complex/insecure client-side queries.

      allow update, delete: if false;
    }

    // == PillReminders Collection ==
    match /pillReminders/{reminderId} {
      allow create: if isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.medicationName is string && request.resource.data.medicationName.size() > 0 &&
                      request.resource.data.times is list && // Ensure 'times' is a list
                      request.resource.data.times.size() > 0; // Ensure at least one time is set

      allow get, list, update, delete: if isPatient() &&
                                   resource.data.patientAuthUid == request.auth.uid &&
                                   (request.method == 'update' ? request.resource.data.patientAuthUid == resource.data.patientAuthUid : true); 
                                   // For update, ensure patientAuthUid is not changed
    }
  }
}

    