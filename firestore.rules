
rules_version = '2';

service cloud.firestore {

  // =================================
  // Helper Functions
  // =================================
  function isAuthenticated() {
    return request.auth != null;
  }

  function isUser(userId) {
    return isAuthenticated() && request.auth.uid == userId;
  }

  function getUserData(userId) {
    if (!(userId is string && userId.size() > 0)) {
      return null;
    }
    // Use string concatenation for dynamic document IDs in paths
    return get(/databases/$(database)/documents/users/ + userId).data;
  }

  function isDoctor() {
    if (!isAuthenticated()) {
      return false;
    }
    // No 'let' keyword. Variables are implicitly declared.
    userData = getUserData(request.auth.uid);
    return userData != null && userData.userType == 'doctor';
  }

  function isPatient() {
    if (!isAuthenticated()) {
      return false;
    }
    userData = getUserData(request.auth.uid);
    return userData != null && userData.userType == 'patient';
  }

  function isDoctorManagingPatientRecord(patientRecordId) {
    if (!isDoctor()) {
      return false;
    }
    if (!(patientRecordId is string && patientRecordId.size() > 0)) {
      return false;
    }
    patientRecord = get(/databases/$(database)/documents/patientRecords/ + patientRecordId).data;
    return patientRecord != null && patientRecord.doctorId == request.auth.uid;
  }

  // Helper to check if the currently authenticated user is the patient linked to a patientRecord,
  // or the doctor managing that patientRecord.
  function isPatientSelfOrManagedByDoctor(patientRecordId) {
    if (!isAuthenticated()) {
      return false;
    }
    if (!(patientRecordId is string && patientRecordId.size() > 0)) {
      return false;
    }
    
    patientRecord = get(/databases/$(database)/documents/patientRecords/ + patientRecordId).data;
    if (patientRecord == null) {
      return false;
    }

    // Case 1: Current user is the patient linked to this record
    if (patientRecord.linkedAuthUid != null && patientRecord.linkedAuthUid == request.auth.uid) {
      return true;
    }

    // Case 2: Current user is a doctor managing this patient
    if (isDoctor() && patientRecord.doctorId == request.auth.uid) {
      return true;
    }
    return false;
  }

  // =================================
  // Database-wide Rules
  // =================================
  match /databases/{database}/documents {

    // =================================
    // Users Collection (/users/{userId})
    // =================================
    match /users/{userId} {
      allow read: if isUser(userId) || isDoctor(); // Doctors can read basic user info (e.g., for patient identification)

      allow create: if isAuthenticated()
                    && request.auth.uid == userId // User can only create their own document
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.email == request.auth.token.email // Verify email against token
                    && request.resource.data.firstName is string && request.resource.data.firstName.size() > 0
                    && request.resource.data.lastName is string && request.resource.data.lastName.size() > 0
                    && (request.resource.data.userType == 'patient' || request.resource.data.userType == 'doctor')
                    && request.resource.data.createdAt is timestamp // Ensure createdAt is a server timestamp on client
                    && request.resource.data.keys().hasAll(['uid', 'email', 'firstName', 'lastName', 'userType', 'createdAt'])
                    && request.resource.data.keys().size() == 6; // Be specific about fields for creation

      allow update: if isUser(userId) // Users can update their own profile
                    // Prevent changing immutable fields
                    && request.resource.data.uid == resource.data.uid
                    && request.resource.data.email == resource.data.email
                    && request.resource.data.userType == resource.data.userType
                    && request.resource.data.createdAt == resource.data.createdAt;
                    // Add validation for other updatable fields (e.g., firstName, lastName are strings)

      allow delete: if false; // Generally, users should not delete their own auth-linked profiles
    }

    // =================================
    // Patient Records Collection (/patientRecords/{recordId})
    // =================================
    match /patientRecords/{recordId} {
      allow read: if isPatientSelfOrManagedByDoctor(recordId) || isDoctorManagingPatientRecord(recordId);

      allow create: if isDoctor()
                    && request.resource.data.doctorId == request.auth.uid
                    && request.resource.data.firstName is string && request.resource.data.firstName.size() > 0
                    && request.resource.data.lastName is string && request.resource.data.lastName.size() > 0
                    && request.resource.data.idNumber is string && request.resource.data.idNumber.size() > 0
                    && request.resource.data.createdAt is timestamp;
                    // Ensure doctorId matches auth uid and validate required fields.
                    // linkedAuthUid should be null or string if present.

      allow update: if isDoctorManagingPatientRecord(recordId)
                    && request.resource.data.doctorId == resource.data.doctorId // doctorId cannot change
                    && request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot change
                    // Validate other fields

      allow delete: if isDoctorManagingPatientRecord(recordId);
    }

    // =================================
    // AI Instructions Collection (/aiInstructions/{doctorId})
    // =================================
    match /aiInstructions/{doctorId} {
      allow read, write: if isUser(doctorId) && isDoctor(); // Only the specific doctor
      // Add data validation for create/update:
      // e.g., for create: request.resource.data.doctorId == doctorId
      // e.g., for update: request.resource.data.doctorId == resource.data.doctorId
      // instructionText must be a string, promptText (optional) must be a string.
    }

    // =================================
    // Appointments Collection (/appointments/{appointmentId})
    // =================================
    // Assumption: appointments.patientId refers to a patientRecordId, NOT a user UID.
    // If appointments.patientId is a User UID, adjust isDoctorManagingPatientRecord calls.
    match /appointments/{appointmentId} {
      allow read: if isAuthenticated() &&
                     ( (isPatient() && request.auth.uid == get(/databases/$(database)/documents/patientRecords/ + resource.data.patientId).data.linkedAuthUid) || // Patient can read their own linked appointments
                       isDoctorManagingPatientRecord(resource.data.patientId) || // Doctor can read appointments of their patients
                       isUser(resource.data.doctorId) // Doctor can read their own appointments
                     );

      allow create: if isAuthenticated() &&
                      ( (isPatient() && request.auth.uid == get(/databases/$(database)/documents/patientRecords/ + request.resource.data.patientId).data.linkedAuthUid) || // Patient creates for their linked record
                        (isDoctor() && isDoctorManagingPatientRecord(request.resource.data.patientId) && request.resource.data.doctorId == request.auth.uid) // Doctor schedules for their patient
                      )
                      // Data validation
                      && request.resource.data.patientId is string
                      && request.resource.data.doctorId is string
                      && request.resource.data.appointmentDate is timestamp;

      allow update: if isAuthenticated() &&
                      ( (isPatient() && request.auth.uid == get(/databases/$(database)/documents/patientRecords/ + resource.data.patientId).data.linkedAuthUid) ||
                        (isDoctor() && resource.data.doctorId == request.auth.uid && isDoctorManagingPatientRecord(resource.data.patientId))
                      )
                      && request.resource.data.patientId == resource.data.patientId // Cannot change patientId
                      && request.resource.data.doctorId == resource.data.doctorId; // Cannot change doctorId

      allow delete: if isAuthenticated() &&
                      ( (isPatient() && request.auth.uid == get(/databases/$(database)/documents/patientRecords/ + resource.data.patientId).data.linkedAuthUid) ||
                        (isDoctor() && resource.data.doctorId == request.auth.uid && isDoctorManagingPatientRecord(resource.data.patientId))
                      );
    }

    // =================================
    // Diagnoses Collection (/diagnoses/{diagnosisId})
    // =================================
    // Assumption: diagnoses.patientId refers to a patientRecordId.
    match /diagnoses/{diagnosisId} {
      allow read: if isAuthenticated() &&
                     ( (isPatient() && request.auth.uid == get(/databases/$(database)/documents/patientRecords/ + resource.data.patientId).data.linkedAuthUid) ||
                       isDoctorManagingPatientRecord(resource.data.patientId) // Doctor can read diagnoses of their patients
                     );

      allow create: if isDoctor() && isDoctorManagingPatientRecord(request.resource.data.patientId)
                     && request.resource.data.diagnosedBy == request.auth.uid // Doctor making diagnosis is the authenticated user
                     // Data validation
                     && request.resource.data.patientId is string
                     && request.resource.data.diagnosisText is string && request.resource.data.diagnosisText.size() > 0
                     && request.resource.data.diagnosisDate is string; // Or timestamp

      allow update: if isDoctor() && resource.data.diagnosedBy == request.auth.uid && isDoctorManagingPatientRecord(resource.data.patientId)
                     && request.resource.data.patientId == resource.data.patientId // Cannot change patientId
                     && request.resource.data.diagnosedBy == resource.data.diagnosedBy; // Cannot change diagnosedBy

      allow delete: if isDoctor() && resource.data.diagnosedBy == request.auth.uid && isDoctorManagingPatientRecord(resource.data.patientId);
    }

    // =================================
    // Patient Documents Collection (/patientDocuments/{documentId})
    // =================================
    // Assumption: patientDocuments.patientId refers to a patientRecordId.
    match /patientDocuments/{documentId} {
      allow read: if isAuthenticated() &&
                     ( (isPatient() && request.auth.uid == get(/databases/$(database)/documents/patientRecords/ + resource.data.patientId).data.linkedAuthUid) ||
                       isDoctorManagingPatientRecord(resource.data.patientId) // Doctor can read documents of their patients
                     );

      allow create: if isDoctor() && isDoctorManagingPatientRecord(request.resource.data.patientId)
                     && request.resource.data.uploadedBy == request.auth.uid // Uploader is the authenticated doctor
                     // Data validation
                     && request.resource.data.patientId is string
                     && request.resource.data.documentName is string && request.resource.data.documentName.size() > 0
                     && request.resource.data.documentPath is string && request.resource.data.documentPath.size() > 0;

      allow delete: if isDoctor() && resource.data.uploadedBy == request.auth.uid && isDoctorManagingPatientRecord(resource.data.patientId);
      // Updates for documents typically involve deleting and re-uploading.
    }

    // =================================
    // Chat Messages Collection (/chatMessages/{chatId})
    // =================================
    // Assumption: chatMessages.patientId refers to the patient's User UID (auth UID).
    match /chatMessages/{chatId} {
      allow read: if isAuthenticated() &&
                    ( isUser(resource.data.patientId) || // Patient can read their own chats
                      // Doctor can read chats if the patientId in chatMessage corresponds to a patientRecord they manage
                      (isDoctor() && exists(/databases/$(database)/documents/patientRecords/ + get(/databases/$(database)/documents/users/ + resource.data.patientId).data.patientRecordId) &&
                                     get(/databases/$(database)/documents/patientRecords/ + get(/databases/$(database)/documents/users/ + resource.data.patientId).data.patientRecordId).data.doctorId == request.auth.uid
                      )
                      // The above assumes users/{patientUID} has a field like 'patientRecordId' that links to their record in 'patientRecords'.
                      // If chatMessages.patientId directly refers to a patientRecordId, simplify the doctor check.
                    );

      allow create: if isAuthenticated() &&
                      (isUser(request.resource.data.patientId) && request.resource.data.senderId == request.auth.uid && request.resource.data.isUser == true)
                      // AI messages must be written via a trusted server environment (e.g., Firebase Function)
                      // For direct client creation of AI messages (not recommended for production):
                      // || (request.resource.data.senderId == "AI_SENDER_ID_PLACEHOLDER" && request.resource.data.isUser == false && isDoctor()) // Example if doctors could trigger AI responses, very specific use case
                      // Data validation
                      && request.resource.data.patientId is string
                      && request.resource.data.senderId is string
                      && request.resource.data.messageText is string && request.resource.data.messageText.size() > 0
                      && request.resource.data.sentAt is timestamp
                      && request.resource.data.isUser is bool;

      allow update: if false; // Chat messages are typically immutable
      allow delete: if false; // Or allow deletion by patient/doctor under certain conditions
    }

    // =================================
    // Pill Reminders Collection (/pillReminders/{reminderId})
    // =================================
    // Assumption: pillReminders.patientUid refers to the patient's User UID (auth UID).
    match /pillReminders/{reminderId} {
      allow read, write: if isAuthenticated() && isUser(request.resource.data.patientUid) || (isAuthenticated() && isUser(resource.data.patientUid) );
      // On create, check request.resource.data.patientUid == request.auth.uid
      // On update/delete, check resource.data.patientUid == request.auth.uid
      // Add detailed field validation for create/update
    }
  }
}

    