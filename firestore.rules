
rules_version = '2';

service cloud.firestore {

  // ==================================
  // == Helper Functions ==
  // ==================================

  function isAuthenticated() {
    return request.auth != null;
  }

  function isDoctor() {
    // Ensure request.auth.uid is available and then check user document
    if (!isAuthenticated() || request.auth.uid == null) {
      return false;
    }
    let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
    // Check if the document exists and then if userType is 'doctor'
    return exists(userDocPath) &&
           get(userDocPath).data.userType == 'doctor';
  }

  function isPatient() {
    if (!isAuthenticated() || request.auth.uid == null) {
      return false;
    }
    let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
    return exists(userDocPath) &&
           get(userDocPath).data.userType == 'patient';
  }

  function isDoctorManagingPatient(patientRecordId) {
    // Ensure patientRecordId is a valid string before using in path
    if (!isDoctor() || !(patientRecordId is string) || patientRecordId.size() == 0) {
      return false;
    }
    let patientRecordPath = /databases/$(database)/documents/patientRecords/$(patientRecordId);
    // Check if the patient record exists and if its doctorId matches the authenticated doctor's UID
    return exists(patientRecordPath) &&
           get(patientRecordPath).data.doctorId == request.auth.uid;
  }

  function isLinkedPatient(patientRecordId) {
    if (!isPatient() || !(patientRecordId is string) || patientRecordId.size() == 0) {
      return false;
    }
    let patientRecordPath = /databases/$(database)/documents/patientRecords/$(patientRecordId);
    return exists(patientRecordPath) &&
           get(patientRecordPath).data.linkedAuthUid == request.auth.uid;
  }

  // ==================================
  // == Collection Rules ==
  // ==================================
  match /databases/{database}/documents {

    // == Users Collection ==
    match /users/{userId} {
      allow create: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.userType is string && (request.resource.data.userType == 'doctor' || request.resource.data.userType == 'patient') &&
                      'createdAt' in request.resource.data; // Client sends serverTimestamp()

      allow read: if isAuthenticated(); // Simplified for debugging and to ensure get() in helpers work. Refine if needed.

      allow update: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      request.resource.data.uid == resource.data.uid &&
                      request.resource.data.email == resource.data.email &&
                      request.resource.data.userType == resource.data.userType &&
                      request.resource.data.createdAt == resource.data.createdAt && // Allow only if existing createdAt is preserved
                      !('uid' in request.resource.data && request.resource.data.uid != resource.data.uid) &&
                      !('email' in request.resource.data && request.resource.data.email != resource.data.email) &&
                      !('userType' in request.resource.data && request.resource.data.userType != resource.data.userType);

      allow delete: if false; // Generally, don't allow users to delete their own accounts directly.
    }

    // == PatientRecords Collection ==
    match /patientRecords/{recordId} {
      allow create: if isDoctor() &&
                      request.resource.data.doctorId == request.auth.uid &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.idNumber is string && request.resource.data.idNumber.size() > 0 &&
                      request.resource.data.initialPassword is string && request.resource.data.initialPassword.size() >= 6 &&
                      'createdAt' in request.resource.data && // Client sends serverTimestamp()
                      !('linkedAuthUid' in request.resource.data); // Cannot set linkedAuthUid on create

      allow get: if isAuthenticated() &&
                   ( isDoctorManagingPatient(recordId) || isLinkedPatient(recordId) );

      // Simplified list rule: Allow if the user is a doctor.
      // The client query MUST then filter by doctorId: where("doctorId", "==", request.auth.uid)
      allow list: if isDoctor();

      allow update: if isDoctorManagingPatient(recordId) &&
                      request.resource.data.doctorId == resource.data.doctorId && // doctorId cannot change
                      'createdAt' in request.resource.data && request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot change
                      // Allow other updates, including linkedAuthUid

      allow delete: if isDoctorManagingPatient(recordId);
    }

    // == AiInstructions Collection ==
    match /aiInstructions/{docId_doctorId} { // Renamed {doctorId} to avoid conflict if this is just an ID
      allow read, write: if isDoctor() && request.auth.uid == docId_doctorId;
    }

    // == Appointments Collection ==
    // IMPORTANT: patientAuthUid should be the Firebase Auth UID of the patient.
    // doctorId should be the Firebase Auth UID of the doctor.
    match /appointments/{appointmentId} {
      allow create: if isAuthenticated() &&
                      ( (isPatient() && request.resource.data.patientAuthUid == request.auth.uid) ||
                        (isDoctor() /* && you might add a check here if this doctor manages the patient they are creating appointment for */ )
                      );

      allow read: if isAuthenticated() &&
                    ( (isPatient() && resource.data.patientAuthUid == request.auth.uid) ||
                      (isDoctor() && resource.data.doctorId == request.auth.uid) );
                      // If doctors need to read appointments of patients they manage (but didn't create),
                      // you'd need a get() on patientRecord similar to other rules.

      allow update, delete: if isAuthenticated() &&
                              ( (isPatient() && resource.data.patientAuthUid == request.auth.uid && request.resource.data.patientAuthUid == resource.data.patientAuthUid) ||
                                (isDoctor() && resource.data.doctorId == request.auth.uid && request.resource.data.doctorId == resource.data.doctorId) );
                                // Ensure key IDs are not changed during update
    }

    // == Diagnoses Collection ==
    // Assumes patientRecordId is the ID of the document in /patientRecords
    match /diagnoses/{diagnosisId} {
      allow create: if isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.diagnosedBy == request.auth.uid;

      allow read: if isAuthenticated() &&
                    ( isDoctorManagingPatient(resource.data.patientRecordId) ||
                      isLinkedPatient(resource.data.patientRecordId) );

      allow update: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      request.resource.data.diagnosedBy == resource.data.diagnosedBy && // diagnosedBy cannot change
                      resource.data.diagnosedBy == request.auth.uid; // Only original diagnosing doctor can update

      allow delete: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.diagnosedBy == request.auth.uid; // Only original diagnosing doctor can delete
    }

    // == PatientDocuments Collection ==
    // Assumes patientRecordId is the ID of the document in /patientRecords
    match /patientDocuments/{documentId} {
      allow create: if isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.uploadedBy == request.auth.uid;

      allow read: if isAuthenticated() &&
                    ( isDoctorManagingPatient(resource.data.patientRecordId) ||
                      isLinkedPatient(resource.data.patientRecordId) );

      allow delete: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.uploadedBy == request.auth.uid; // Only original uploader can delete
    }

    // == ChatMessages Collection ==
    match /chatMessages/{chatId} {
      allow create: if isAuthenticated() &&
                      isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.resource.data.isUser == true; // Ensure client only sends their own messages

      // Patient can read their own messages.
      // Doctor access to patient chats is complex for direct client query due to rules limitations.
      // Typically requires a backend mechanism or a specific data duplication/linking strategy if doctors need to read all chats.
      // For now, only patient can read.
      allow read: if isAuthenticated() &&
                    isPatient() &&
                    resource.data.patientAuthUid == request.auth.uid;

      allow update, delete: if false; // Chat messages are typically immutable
    }

    // == PillReminders Collection ==
    match /pillReminders/{reminderId} {
      allow create: if isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid;

      allow read, delete: if isPatient() &&
                            resource.data.patientAuthUid == request.auth.uid;

      allow update: if isPatient() &&
                      resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.patientAuthUid == resource.data.patientAuthUid; // Ensure patientAuthUid is not changed
    }
  }
}

    