
rules_version = '2';

service cloud.firestore {

  // ==================================
  // == Helper Functions ==
  // ==================================

  function isAuthenticated() {
    return request.auth != null;
  }

  function isDoctor() {
    // Ensure request.auth is not null before trying to access request.auth.uid
    if (!isAuthenticated()) {
      return false;
    }
    let userData = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    return userData != null && userData.userType == 'doctor';
  }

  function isPatient() {
    // Ensure request.auth is not null before trying to access request.auth.uid
    if (!isAuthenticated()) {
      return false;
    }
    let userData = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    return userData != null && userData.userType == 'patient';
  }

  // Check if the authenticated doctor manages the patient record.
  function isDoctorManagingPatient(patientRecordId) {
    if (!isDoctor() || !(patientRecordId is string && patientRecordId.size() > 0) ) {
      return false;
    }
    let patientRecord = get(/databases/$(database)/documents/patientRecords/ + patientRecordId).data;
    return patientRecord != null &&
           patientRecord.doctorId == request.auth.uid;
  }

  // Check if the authenticated patient is linked to the patient record.
  function isLinkedPatient(patientRecordId) {
     if (!isPatient() || !(patientRecordId is string && patientRecordId.size() > 0) ) {
      return false;
    }
    let patientRecord = get(/databases/$(database)/documents/patientRecords/ + patientRecordId).data;
    return patientRecord != null &&
           patientRecord.linkedAuthUid == request.auth.uid;
  }

  // ==================================
  // == Collection Rules ==
  // ==================================

  match /databases/{database}/documents {

    // == Users Collection ==
    match /users/{userId} {
      allow create: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.userType is string && (request.resource.data.userType == 'doctor' || request.resource.data.userType == 'patient') &&
                      request.resource.data.createdAt == request.time; // For user creation, client should send actual date or server handles it.

      allow read: if isAuthenticated() && (request.auth.uid == userId || isDoctor());

      allow update: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      // Prevent changing critical fields
                      request.resource.data.uid == resource.data.uid &&
                      request.resource.data.email == resource.data.email &&
                      request.resource.data.userType == resource.data.userType &&
                      request.resource.data.createdAt == resource.data.createdAt &&
                      // Allow other fields to be updated (e.g., firstName, lastName)
                      request.resource.data.keys().hasAll(['uid', 'email', 'firstName', 'lastName', 'userType', 'createdAt']) &&
                      request.resource.data.keys().size() == resource.data.keys().size();


      allow delete: if false; // Generally, don't allow users to delete their own accounts directly via client.
    }

    // == PatientRecords Collection ==
    match /patientRecords/{recordId} {
      allow create: if isDoctor() &&
                      request.resource.data.doctorId == request.auth.uid &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.idNumber is string && request.resource.data.idNumber.size() > 0 &&
                      request.resource.data.initialPassword is string && request.resource.data.initialPassword.size() >= 6 &&
                      // request.resource.data.createdAt == request.time; // REMOVED: This is incorrect for serverTimestamp() on create
                      !('linkedAuthUid' in request.resource.data); // linkedAuthUid should not be set on creation by doctor

      allow read: if isAuthenticated() &&
                    ( isDoctorManagingPatient(recordId) || isLinkedPatient(recordId) );

      allow update: if isDoctorManagingPatient(recordId) &&
                      request.resource.data.doctorId == resource.data.doctorId && // doctorId cannot change
                      request.resource.data.idNumber == resource.data.idNumber && // idNumber (patient ID) usually shouldn't change
                      request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot change
                      // Allow other updates, e.g., firstName, lastName, address, phoneNumber, patientSpecificPrompts, initialPassword (if needed), linkedAuthUid

      allow delete: if isDoctorManagingPatient(recordId);
    }

    // == AiInstructions Collection ==
    match /aiInstructions/{doctorId} {
      allow read, write: if isDoctor() && request.auth.uid == doctorId;
    }

    // == Appointments Collection ==
    match /appointments/{appointmentId} {
      allow create: if isAuthenticated() &&
                      (
                        (isPatient() && request.resource.data.patientAuthUid == request.auth.uid) ||
                        (isDoctor() && request.resource.data.doctorId == request.auth.uid) // Doctor can create for themselves or patients they manage
                        // Further validation might be needed if doctor creates for a patient:
                        // && isDoctorManagingPatientByPatientAuthUid(request.resource.data.patientAuthUid)
                      );

      allow read: if isAuthenticated() &&
                    (
                      (isPatient() && resource.data.patientAuthUid == request.auth.uid) ||
                      (isDoctor() && resource.data.doctorId == request.auth.uid) || // Doctor can read their own appointments
                      (isDoctor() && isDoctorManagingPatientByPatientAuthUid(resource.data.patientAuthUid)) // Doctor can read appointments of patients they manage
                    );

      allow update, delete: if isAuthenticated() &&
                              (
                                (isPatient() && resource.data.patientAuthUid == request.auth.uid && request.resource.data.patientAuthUid == request.auth.uid) ||
                                (isDoctor() && resource.data.doctorId == request.auth.uid && request.resource.data.doctorId == request.auth.uid)
                                // Add checks if doctor is updating/deleting patient's appointment
                              );
    }

    // == Diagnoses Collection ==
    match /diagnoses/{diagnosisId} {
      allow create: if isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.diagnosedBy == request.auth.uid;

      allow read: if isAuthenticated() &&
                    ( isDoctorManagingPatient(resource.data.patientRecordId) ||
                      isLinkedPatient(resource.data.patientRecordId) );

      allow update, delete: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                              resource.data.diagnosedBy == request.auth.uid;
    }

    // == PatientDocuments Collection ==
    match /patientDocuments/{documentId} {
      allow create: if isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.uploadedBy == request.auth.uid;

      allow read: if isAuthenticated() &&
                    ( isDoctorManagingPatient(resource.data.patientRecordId) ||
                      isLinkedPatient(resource.data.patientRecordId) );

      allow delete: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.uploadedBy == request.auth.uid;
    }

    // == ChatMessages Collection ==
    // Note: Doctor access to all chats of a patient they manage is complex with rules alone.
    // Typically, this requires a backend function or specific data duplication.
    // For simplicity, these rules allow patients to read/write their own messages.
    // Doctor read access would need a different data model or backend logic.
    match /chatMessages/{chatId} {
      allow create: if isAuthenticated() &&
                      isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.resource.data.isUser == true; // Only patient can send 'user' messages

      allow read: if isAuthenticated() &&
                    isPatient() &&
                    resource.data.patientAuthUid == request.auth.uid;
                    // For doctor read: Needs a way to link chatMessage to patientRecord to check doctorId

      allow update, delete: if false; // Messages are generally immutable
    }

    // == PillReminders Collection ==
    match /pillReminders/{reminderId} {
      allow create: if isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid;

      allow read, delete: if isPatient() &&
                            resource.data.patientAuthUid == request.auth.uid;

      allow update: if isPatient() &&
                      resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.patientAuthUid == request.auth.uid; // Ensure patientAuthUid isn't changed
    }
  }
  // Helper for Appointments/Diagnoses if you identify patients by their auth UID in those records
  // This is an example and might need to be adapted based on your exact data structure
  // for linking patient auth UIDs to patient records managed by doctors.
  // It assumes there's a way to query/get patientRecords by patientAuthUid,
  // which isn't directly efficient in rules without knowing the patientRecordId.
  // For now, I've kept the logic simpler in the main rules using patientRecordId.
  // function isDoctorManagingPatientByPatientAuthUid(patientAuthUid) {
  //   // This is pseudo-code for a more complex check.
  //   // You'd need a reliable way to get from patientAuthUid to a patientRecord
  //   // and then check its doctorId. This often involves a specific data structure
  //   // or a backend check.
  //   // For example, if patientRecords had a field 'linkedAuthUid':
  //   // return isDoctor() && exists(/databases/$(database)/documents/patientRecords?where=linkedAuthUid,==,patientAuthUid,doctorId,==,request.auth.uid);
  //   // However, queries in rules are limited. A direct get() is better if you have the ID.
  //   return false; // Placeholder - implement if needed with proper data model
  // }
}

    