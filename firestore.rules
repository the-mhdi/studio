
rules_version = '2';

service cloud.firestore {

  // ===== Helper Functions =====
  function isAuthenticated() {
    return request.auth != null;
  }

  function isUser(userId) {
    return isAuthenticated() && request.auth.uid == userId;
  }

  function getUserData(userId) {
    // Ensure userId is a valid string before using in path
    if (!(userId is string && userId.size() > 0)) {
      return null; // Or handle error appropriately, returning null means subsequent checks might fail cleanly
    }
    return get(/databases/$(database)/documents/users/ + userId).data;
  }

  function isDoctor() {
    if (!isAuthenticated()) {
      return false;
    }
    let userData = getUserData(request.auth.uid);
    return userData != null && userData.userType == 'doctor';
  }

  function isPatient() {
    if (!isAuthenticated()) {
      return false;
    }
    let userData = getUserData(request.auth.uid);
    return userData != null && userData.userType == 'patient';
  }

  // Function to check if the requesting doctor is the one associated with a given patientRecordId
  function isDoctorManagingPatientViaRecord(patientRecordId) {
    if (!isDoctor()) {
      return false;
    }
    if (!(patientRecordId is string && patientRecordId.size() > 0)) {
      return false;
    }
    let patientRecord = get(/databases/$(database)/documents/patientRecords/ + patientRecordId).data;
    return patientRecord != null && patientRecord.doctorId == request.auth.uid;
  }

  // Function to check if the requesting patient is the one associated with a given patientRecordId
  // This assumes patientRecord has a field like 'linkedAuthUid' that stores the patient's actual auth UID.
  function isPatientAssociatedWithRecord(patientRecordId) {
     if (!isPatient()){
        return false;
     }
    if (!(patientRecordId is string && patientRecordId.size() > 0)) {
        return false;
    }
    let patientRecord = get(/databases/$(database)/documents/patientRecords/ + patientRecordId).data;
    return patientRecord != null && patientRecord.linkedAuthUid == request.auth.uid;
  }

  // ===== Database Rules =====
  match /databases/{database}/documents {

    match /users/{userId} {
      allow read: if isUser(userId) || isDoctor(); // Doctors can read user profiles for system needs (e.g. linking names), patients only their own.
      
      allow create: if request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                       request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                       (request.resource.data.userType == 'patient' || request.resource.data.userType == 'doctor') &&
                       request.resource.data.createdAt == request.time && // Ensure createdAt is server timestamp on create
                       request.resource.data.size() == 6; // Strict field count: uid, email, firstName, lastName, userType, createdAt

      allow update: if isUser(userId) &&
                       request.resource.data.uid == resource.data.uid && 
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.userType == resource.data.userType &&
                       request.resource.data.createdAt == resource.data.createdAt; 
                       // Allow other fields (firstName, lastName) to be updated by the user.
      allow delete: if false; // Users should not delete their own auth-linked profiles directly.
    }

    match /patientRecords/{recordId} {
      allow read: if isDoctorManagingPatientViaRecord(recordId) ||
                     (isPatient() && isPatientAssociatedWithRecord(recordId));
      
      allow create: if isDoctor() &&
                       request.resource.data.doctorId == request.auth.uid &&
                       request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                       request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                       request.resource.data.idNumber is string && request.resource.data.idNumber.size() > 0 &&
                       request.resource.data.createdAt == request.time;
                       // linkedAuthUid (optional) might be set later or not at all initially

      allow update: if isDoctorManagingPatientViaRecord(recordId) &&
                       request.resource.data.doctorId == resource.data.doctorId; // Doctor ID cannot change on update
      allow delete: if isDoctorManagingPatientViaRecord(recordId);
    }

    match /aiInstructions/{doctorId} {
      allow read, write: if isDoctor() && request.auth.uid == doctorId;
      // Add specific field validation for 'write' operations (create, update)
      // E.g., ensure instructionText is string, promptText is string or null, etc.
      // allow update: if isDoctor() && request.auth.uid == doctorId && request.resource.data.doctorId == resource.data.doctorId;
    }

    match /appointments/{appointmentId} {
      allow read: if (isDoctor() && isDoctorManagingPatientViaRecord(get(/databases/$(database)/documents/appointments/$(appointmentId)).data.patientId)) || 
                     (isPatient() && request.auth.uid == get(/databases/$(database)/documents/appointments/$(appointmentId)).data.patientId); 
      
      allow create: if (isPatient() && request.resource.data.patientId == request.auth.uid) || 
                       (isDoctor() && isDoctorManagingPatientViaRecord(request.resource.data.patientId) && request.resource.data.doctorId == request.auth.uid);
                       // Add field validation: appointmentDate, doctorId, patientId must exist and be correct types/formats.
                       // request.resource.data.appointmentDate is timestamp;
                       // request.resource.data.patientId is string;
                       // request.resource.data.doctorId is string;
                       // request.resource.data.createdAt == request.time;

      allow update: if ((isDoctor() && isDoctorManagingPatientViaRecord(resource.data.patientId) && resource.data.doctorId == request.auth.uid) ||
                        (isPatient() && request.auth.uid == resource.data.patientId)) &&
                       request.resource.data.patientId == resource.data.patientId && 
                       request.resource.data.doctorId == resource.data.doctorId;
                       // Allow updating reason, notes, or appointmentDate by authorized parties.

      allow delete: if (isDoctor() && isDoctorManagingPatientViaRecord(resource.data.patientId) && resource.data.doctorId == request.auth.uid) ||
                       (isPatient() && request.auth.uid == resource.data.patientId);
    }

    match /diagnoses/{diagnosisId} {
      // Assuming patientId in diagnoses refers to a patientRecord's ID.
      allow read: if (isDoctor() && isDoctorManagingPatientViaRecord(get(/databases/$(database)/documents/diagnoses/$(diagnosisId)).data.patientId)) ||
                     (isPatient() && isPatientAssociatedWithRecord(get(/databases/$(database)/documents/diagnoses/$(diagnosisId)).data.patientId));
      
      allow create: if isDoctor() && isDoctorManagingPatientViaRecord(request.resource.data.patientId) &&
                       request.resource.data.diagnosedBy == request.auth.uid;
                       // Add field validation: diagnosisText, diagnosisDate etc.
                       // request.resource.data.createdAt == request.time;

      allow update: if isDoctor() && isDoctorManagingPatientViaRecord(resource.data.patientId) &&
                       resource.data.diagnosedBy == request.auth.uid && // Only diagnosing doctor can update
                       request.resource.data.patientId == resource.data.patientId &&
                       request.resource.data.diagnosedBy == resource.data.diagnosedBy;

      allow delete: if isDoctor() && isDoctorManagingPatientViaRecord(resource.data.patientId) &&
                       resource.data.diagnosedBy == request.auth.uid; // Only diagnosing doctor can delete
    }

    match /patientDocuments/{documentId} {
      // Assuming patientId in patientDocuments refers to a patientRecord's ID.
      allow read: if (isDoctor() && isDoctorManagingPatientViaRecord(get(/databases/$(database)/documents/patientDocuments/$(documentId)).data.patientId)) ||
                     (isPatient() && isPatientAssociatedWithRecord(get(/databases/$(database)/documents/patientDocuments/$(documentId)).data.patientId));
      
      allow create: if isDoctor() && isDoctorManagingPatientViaRecord(request.resource.data.patientId) &&
                       request.resource.data.uploadedBy == request.auth.uid;
                       // Add field validation: documentName, documentPath, uploadedAt etc.
                       // request.resource.data.uploadedAt == request.time;
      
      allow delete: if isDoctor() && isDoctorManagingPatientViaRecord(resource.data.patientId) &&
                       resource.data.uploadedBy == request.auth.uid;
      allow update: if false; // Documents are typically immutable; new versions are new documents.
    }

    match /chatMessages/{chatId} {
      // Assuming patientId in chatMessages refers to the patient's auth UID.
      allow read: if (isPatient() && request.auth.uid == get(/databases/$(database)/documents/chatMessages/$(chatId)).data.patientId) ||
                     (isDoctor() && isDoctorManagingPatientViaRecord(get(/databases/$(database)/documents/chatMessages/$(chatId)).data.patientRecordId)); 
                     // This assumes chatMessages has a patientRecordId field for doctor lookup.
                     // Adjust if linkage is different (e.g., doctor can see all their patients' chats based on patient UID).
      
      allow create: if (isPatient() && 
                        request.resource.data.patientId == request.auth.uid &&
                        request.resource.data.senderId == request.auth.uid &&
                        request.resource.data.isUser == true);
                       // AI messages would be written by a backend function with admin/service account privileges.
                       // request.resource.data.sentAt == request.time;
      
      allow update, delete: if false; // Chat messages are generally immutable.
    }

    match /pillReminders/{reminderId} {
      // Assuming patientUid on reminder doc refers to the patient's auth UID.
      allow read, write: if isPatient() && request.auth.uid == get(/databases/$(database)/documents/pillReminders/$(reminderId)).data.patientUid;
      
      // On create, ensure patientUid matches auth.uid
      // This is covered by the 'write' rule condition if document exists.
      // For create, we'd need to ensure it in request.resource.data for new docs.
      // So, splitting for clarity:
      allow create: if isPatient() && request.resource.data.patientUid == request.auth.uid;
                      // Add field validation for medicationName, dosage, frequency, times
      allow update: if isPatient() && request.auth.uid == resource.data.patientUid &&
                       request.resource.data.patientUid == resource.data.patientUid; // patientUid cannot change
      allow delete: if isPatient() && request.auth.uid == resource.data.patientUid;
    }
  }
}

    