
rules_version = '2';

service cloud.firestore {

  // ==================================
  // == Helper Functions ==
  // ==================================

  function isAuthenticated() {
    return request.auth != null;
  }

  function isDoctor() {
    // Ensure request.auth.uid is available before trying to get user data
    if (!isAuthenticated() || request.auth.uid == null) {
      return false;
    }
    let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
    // Check document existence before accessing .data
    return exists(userDocPath) &&
           get(userDocPath).data.userType == 'doctor';
  }

  function isPatient() {
    if (!isAuthenticated() || request.auth.uid == null) {
      return false;
    }
    let userDocPath = /databases/$(database)/documents/users/$(request.auth.uid);
    return exists(userDocPath) &&
           get(userDocPath).data.userType == 'patient';
  }

  // Check if the authenticated doctor manages the patient record.
  function isDoctorManagingPatient(patientRecordId) {
    // Ensure patientRecordId is a string and not empty before using in path
    if (!isDoctor() || !(patientRecordId is string) || patientRecordId.size() == 0) {
      return false;
    }
    let patientRecordPath = /databases/$(database)/documents/patientRecords/$(patientRecordId);
    return exists(patientRecordPath) &&
           get(patientRecordPath).data.doctorId == request.auth.uid;
  }

  // Check if the authenticated patient is linked to the patient record.
  function isLinkedPatient(patientRecordId) {
     // Ensure patientRecordId is a string and not empty
    if (!isPatient() || !(patientRecordId is string) || patientRecordId.size() == 0) {
      return false;
    }
    let patientRecordPath = /databases/$(database)/documents/patientRecords/$(patientRecordId);
    return exists(patientRecordPath) &&
           get(patientRecordPath).data.linkedAuthUid == request.auth.uid;
  }

  // ==================================
  // == Collection Rules ==
  // ==================================
  match /databases/{database}/documents {

    // == Users Collection ==
    match /users/{userId} {
      allow create: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.userType is string && (request.resource.data.userType == 'doctor' || request.resource.data.userType == 'patient') &&
                      request.resource.data.createdAt == request.time;

      allow read: if isAuthenticated(); // Allows isDoctor/isPatient helpers to work by reading user profiles

      allow update: if isAuthenticated() &&
                      request.auth.uid == userId &&
                      // Prevent changing critical fields
                      request.resource.data.uid == resource.data.uid &&
                      request.resource.data.email == resource.data.email &&
                      request.resource.data.userType == resource.data.userType &&
                      request.resource.data.createdAt == resource.data.createdAt;
                      // Allow other fields like firstName, lastName to be updated

      allow delete: if false; // Generally, users shouldn't delete their own accounts directly via client
    }

    // == PatientRecords Collection ==
    match /patientRecords/{recordId} {
      allow create: if isDoctor() &&
                      request.resource.data.doctorId == request.auth.uid &&
                      request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                      request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                      request.resource.data.idNumber is string && request.resource.data.idNumber.size() > 0 &&
                      request.resource.data.initialPassword is string && request.resource.data.initialPassword.size() >= 6 &&
                      // serverTimestamp() is used for createdAt, so don't check against request.time on create
                      'createdAt' in request.resource.data && 
                      !('linkedAuthUid' in request.resource.data); // linkedAuthUid cannot be set on create by doctor

      // Rule for allowing Patient ID based login to query records.
      // WARNING: THIS IS BROAD. Replace with a Cloud Function for production.
      // It allows unauthenticated reads if specific fields are queried, which is complex to secure perfectly.
      // For now, allowing any authenticated user to read to simplify debugging client side.
      // Or, for the specific Patient ID login query:
      allow get: if isAuthenticated() && (isDoctorManagingPatient(recordId) || isLinkedPatient(recordId));
      allow list: if isDoctor(); // Doctors can list records, client query must filter by doctorId


      allow update: if isDoctorManagingPatient(recordId) &&
                      // Prevent changing key identifiers
                      request.resource.data.doctorId == resource.data.doctorId &&
                      request.resource.data.idNumber == resource.data.idNumber &&
                      request.resource.data.createdAt == resource.data.createdAt;
                      // Allow other fields to be updated by the managing doctor

      allow delete: if isDoctorManagingPatient(recordId);
    }

    // == AiInstructions Collection ==
    // Using a placeholder for the wildcard as {doctorId} can be ambiguous if a field is also named doctorId
    match /aiInstructions/{docId_doctorId} {
      allow read, write: if isDoctor() && request.auth.uid == docId_doctorId;
    }

    // == Appointments Collection ==
    match /appointments/{appointmentId} {
      allow create: if isAuthenticated() &&
                      ( (isPatient() && request.resource.data.patientAuthUid == request.auth.uid) ||
                        // If doctor creates, ensure they manage the patient (if patientRecordId is provided)
                        (isDoctor() && (request.resource.data.patientRecordId == null || isDoctorManagingPatient(request.resource.data.patientRecordId)))
                      ) &&
                      request.resource.data.doctorId is string &&
                      request.resource.data.patientAuthUid is string &&
                      request.resource.data.appointmentDate is string; // And other validations

      allow read: if isAuthenticated() &&
                    ( (isPatient() && resource.data.patientAuthUid == request.auth.uid) ||
                      (isDoctor() && resource.data.doctorId == request.auth.uid) ); // Doctor can read their appointments

      allow update: if isAuthenticated() &&
                      ( (isPatient() && resource.data.patientAuthUid == request.auth.uid && request.resource.data.patientAuthUid == resource.data.patientAuthUid) ||
                        (isDoctor() && resource.data.doctorId == request.auth.uid && request.resource.data.doctorId == resource.data.doctorId) ) &&
                      // Prevent changing key IDs on update
                      request.resource.data.patientAuthUid == resource.data.patientAuthUid &&
                      request.resource.data.doctorId == resource.data.doctorId;

      allow delete: if isAuthenticated() &&
                      ( (isPatient() && resource.data.patientAuthUid == request.auth.uid) ||
                        (isDoctor() && resource.data.doctorId == request.auth.uid) );
    }

    // == Diagnoses Collection ==
    match /diagnoses/{diagnosisId} {
      allow create: if isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.diagnosedBy == request.auth.uid &&
                      request.resource.data.patientRecordId is string &&
                      request.resource.data.diagnosisText is string && request.resource.data.diagnosisText.size() > 0 &&
                      request.resource.data.diagnosisDate is string;

      allow get: if isAuthenticated() &&
                    ( isDoctorManagingPatient(resource.data.patientRecordId) ||
                      isLinkedPatient(resource.data.patientRecordId) );
      allow list: if isDoctor(); // Client must filter by patientRecordId and that doctor's own ID

      allow update: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.diagnosedBy == request.auth.uid &&
                      request.resource.data.diagnosedBy == resource.data.diagnosedBy && // Cannot change who diagnosed
                      request.resource.data.patientRecordId == resource.data.patientRecordId; // Cannot change patient

      allow delete: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.diagnosedBy == request.auth.uid;
    }

    // == PatientDocuments Collection ==
    match /patientDocuments/{documentId} {
      allow create: if isDoctorManagingPatient(request.resource.data.patientRecordId) &&
                      request.resource.data.uploadedBy == request.auth.uid &&
                      request.resource.data.patientRecordId is string &&
                      request.resource.data.documentName is string && request.resource.data.documentName.size() > 0 &&
                      request.resource.data.documentPath is string && request.resource.data.documentPath.size() > 0;

      allow get: if isAuthenticated() &&
                    ( isDoctorManagingPatient(resource.data.patientRecordId) ||
                      isLinkedPatient(resource.data.patientRecordId) );
      allow list: if isDoctor(); // Client must filter by patientRecordId and that doctor's own ID

      allow delete: if isDoctorManagingPatient(resource.data.patientRecordId) &&
                      resource.data.uploadedBy == request.auth.uid;
    }

    // == ChatMessages Collection ==
    match /chatMessages/{chatId} {
      allow create: if isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.senderId == request.auth.uid &&
                      request.resource.data.isUser == true &&
                      request.resource.data.messageText is string && request.resource.data.messageText.size() > 0;
                      // AI responses would be written by a backend function with admin privileges

      allow list: if isPatient() && request.query.resource.data.patientAuthUid == request.auth.uid; // Patient can list their own messages
                      // Doctor access to chat history is complex via rules; ideally via backend or specific data duplication.
                      // For now, doctors cannot list all chat messages directly via client query securely.

      allow get: if isPatient() && resource.data.patientAuthUid == request.auth.uid; // Patient can get their own message

      allow update, delete: if false; // Chat messages are generally immutable
    }

    // == PillReminders Collection ==
    match /pillReminders/{reminderId} {
      allow create: if isPatient() &&
                      request.resource.data.patientAuthUid == request.auth.uid &&
                      request.resource.data.medicationName is string && request.resource.data.medicationName.size() > 0 &&
                      request.resource.data.dosage is string &&
                      request.resource.data.frequency is string &&
                      request.resource.data.times is list;

      allow read, update, delete: if isPatient() &&
                            resource.data.patientAuthUid == request.auth.uid &&
                            // For update, ensure patientAuthUid is not changed
                            (request.method == 'update' ? request.resource.data.patientAuthUid == resource.data.patientAuthUid : true);
      allow list: if isPatient() && request.query.resource.data.patientAuthUid == request.auth.uid;
    }
  }
}
